;
; Copyright 2025 AESilky (SilkyDESIGN)
; SPDX-License-Identifier: MIT
;

; Receive serial data from an SBUS RC receiver.;
; The SM clock should be set to 16x the SBUS BAUD rate (100,000 * 16).
;
.pio_version RP2350

.program rx_sbus
; Read serial data that is inverted (idle line and STOP bit is LOW
;  and START bit is HIGH)
;
; SBUS is START-8Data-EvenParity-2STOP ( ___-01234567P__)
; A single SBUS message is 25 bytes long, and there is a moderately long idle
; period between messages. Therefore, when the program is started, it will
; wait for a short idle period before starting to read data. Since the start
; bit is a 1, if we get 12 0-bits we have reached an idle period.
;
; To check the Even-Parity, the OSR is loaded with 1010,1010,1010,0000
;  (every other bit 1 for 11 bits - reading from the left).
; Then, as data bits are received, if the bit is a 1, we shift (left) a single
; bit from the OSR. So, after one '1' bit, the OSR has 0101,0101,0100,0000.
; This continues as '1' bits are received. At the point we receive the parity
; bit, the MSb of the OSR should be the inverse of the parity bit value.
; Having the inverse of the parity allows jumping on '!=' (supported) rather
; than '==' (not supported).
;
; If either a parity error or a framing error occurs, the SM interrupts the
; system. IRQ bit 0 indicates an error, IRQ bit 4 (in addition) indicates
; that it was a parity error.
;
.define MIN_GAP_BITS 12 ; the bits needed for a 'gap'
.fifo rx                ; Use both FIFOs for RX
.in 32 right            ; Shift right, no auto-push
.out 32 left            ; Shift left, no auto-pull
;.mov_status irq set 0   ; Status is from IRQ bit 0

PUBLIC start:
    set x, MIN_GAP_BITS
    wait 0 pin 0 [16/2]     ; Stall until we see a 0, then delay 1/2 bit time
idleloop:
    jmp pin, start          ; 1. We received a 1 before enough 0's for idle
    jmp x--, idleloop [16 - 2]  ; 2. Count the 0 [delay 1 bit-time]
    ; We've received enough 0's for the idle period
.wrap_target
    set y, 0b10101          ; Setup for Even-Parity check, put 1010,1010,1010,0000 in the OSR
    in y, 5                 ; Shift 5 bits in  (ISR has 1010,1000,0000,0000)
    mov y, !y               ; Y gets 1111,1111,1110,1010
    in y, 6                 ;  shift 6 bits in (ISR has 1010,1010,1010,0000)
    mov osr, isr            ; Put the 1010,1010,1010,0000 into the OSR
    mov isr, !x             ; Clear ISR (x contains 0xFF from above op or chk_stop below)
    wait 1 pin 0 [16 - 1]   ; Stall until start bit is received, then delay 1 bit time
    set x, 7 [(16/2) - 1]   ; 1. Preload bit counter and delay 1/2 bit time
bitloop:
    mov y, pins             ; 1. Read the bit into 'Y'
    mov y, !y               ; 2. SBUS data is inverted, invert so system gets correct data
    in y, 1                 ; 3. Shift it in to the ISR
    mov y, !y               ; 4. Put 'Y' back so the logic below works
    ; Check for a 1-bit and if so, shift the next bit from the OSR
    jmp y--, bit_is_one     ; 5.
    jmp count_bit           ; 6. Go to the bit count
bit_is_one:
    out y, 1                ; 6. The data was a '1', shift a bit out of the OSR
count_bit:
    jmp x-- bitloop [16 - 7]    ; 7. Get next bit (need 1 bit delay upon jumping).
    ; This next bit is the parity bit
    mov x, pins             ; 1.
    ; Check that the parity is correct
    out y, 1                ; 2. Get the !parity bit from the OSR
    jmp x!=y, get_stop      ; 3. Parity is good, get the stop bits
    ; The Parity is bad. Interrupt the system
    jmp bad_parity
get_stop:
    set x, 1 [16 - 4]       ; 4. Need 2 stop bits
chk_stop:
    jmp pin framing_error   ; 1. Check stop bit. Should be low (remember SBUS is inverse)
    jmp x--, chk_stop  [16 - 1] ; 2. Not 2 stop bits yet, check again.
good_data:
    ;in null, 24             ; Pad the ISR with 0's
    push NOBLOCK            ; Push this byte (this also clears the ISR)
.wrap
    ; Either a framing error or a break. Interrupt the system
bad_parity:
    irq set 4               ; Set IRQ-4 (in addition to 0) for parity error (don't wait yet)
framing_error:
    irq wait 0              ; Set IRQ-0 for either error and wait for it to be cleared
restart:
    jmp start               ; Don't push data if we didn't see good framing, wait for gap.

