/**
 * Expansion I/O SPI operations.
 *
 * The Expansion I/O SPI is shared with the Display. In addition, the SPI Chip-Selects
 * are generated by a single 2:4 decoder, such that only a single SPI device can be
 * selected at a time.
 *
 * The reason the devices are split across two HW SPI units is because the Touch
 * Panel SCK speed is much slower than the Display and the Expansion I/O.
 *
 * Copyright 2023-24 AESilky
 * SPDX-License-Identifier: MIT License
 *
 */
#include "expio.h"
#include "system_defs.h"
#include "spi_ops.h"

#define EIO_CONTROL_BYTE    0x40    // 0100 0 (fixed) 00 (addr) x (0=WR, 1=RD)
#define EIO_CONTROL_WR_EN   0x00    // Bit-0 is WR/RD Control 0=WR
#define EIO_CONTROL_RD_EN   0x01    //                        1=RD

// Note: The final part of the definition names below are not the most clear,
// but they match the Microchip MCP23S08 Datasheet. This makes it easier to
// correlate information between the datasheet and this module.

#define EIO_REG_IODIR       0x00  // I/O Direction. 1=Input, 0=Output (R/W, POR=1111 1111)
#define EIO_REG_IPOL        0x01  // Input Polarity. 1=Invert (R/W, POR=0000 0000)
#define EIO_REG_GPINTEN     0x02  // Interrupt-On-Change enable. 1=Enable (R/W, POR=0000 0000)
#define EIO_REG_DEFVAL      0x03  // Default Value for IntOnChg. (R/W, POR=0000 0000)
#define EIO_REG_INTCON      0x04  // Interrupt Control. Compare to Default or Previous. (R/W, POR=0000 0000)
#define EIO_REG_IOCON       0x05  // Device Configuration. See bits below. (R/W, POR=xx00 000x)
#define EIO_IOCON_SEQOP_DIS_BIT     0x20  // Sequential Operation. Bit Set/Clr in IOCON Register
#define EIO_IOCON_DISSLW_BIT        0x10  // SDA Slew Rate. Bit Set/Clr in IOCON Register
#define EIO_IOCON_HAEN_BIT          0x08  // HW ADDR Enable. Bit Set/Clr in IOCON Register
#define EIO_IOCON_ODR_BIT           0x04  // Open-Drain Int Pin Enable. Bit Set/Clr in IOCON Register
#define EIO_IOCON_INTPOL_BIT        0x02  // Int Polarity. Bit Set/Clr in IOCON Register
#define EIO_REG_GPPU        0x06  // Pull-Up control. 1=PU (R/W, POR=)
#define EIO_REG_INTF        0x07  // Interrupt Flag. 1=Pin caused int. (RO, POR=0000 0000)
#define EIO_REG_INTCAP      0x08  // Interrupt Capture. Port values when int first occurs.
#define EIO_REG_GPIO        0x09  // GPIO (port) value. Reads current pin values, Write sets OLAT.
#define EIO_REG_OLAT        0x0A  // Output Latch. Writing sets pins configured as Output. Read is of last written value.

// Expansion I/O Board Pins

#define EIO_LED_A                       4  // Aux General Purpose 4 - Connected to a header and LED-A (OUT)
#define EIO_LED_B                       5  // Aux General Purpose 5 - Connected to a header and LED-B (OUT)
#define EIO_BOARD_ADDR                  7  // Board Address (IN)
#define EIO_DISPLAY_BL_EN               6  // Display Backlight Enable (OUT)
#define EIO_SERVO_POWER_A_EN            0  // Servo Power Bus-A Enable (OUT)
#define EIO_SERVO_POWER_B_EN            1  // Servo Power Bus-B Enable (OUT)
#define EIO_SERVO_POWER_SENSE_EN        2  // Servo Power Current Sense Enable (OUT)
#define EIO_SERVO_POWER_SENSE_AB_SEL    3  // Servo Power Current Sense Select (0=A, 1=B)
//
#define EIO_GPIO_DIRECTIONS             0x80  // 1000 0000

static void _eio_write(uint8_t reg, uint8_t val) {
    // ZZZ - TODO
}

void eio_display_backlight_on(bool on) {
    // ZZZ - TODO
}

void expio_module_init(void) {
    static bool _initialized = false;

    if (_initialized) {
        panic("expio_module_init called multiple times.");
    }
    _initialized = true;

    // Values are written to all of the chip's registers, even though many
    // contain the desired values after the chip's Power-On-Reset.
    _eio_write(EIO_REG_IOCON, EIO_IOCON_SEQOP_DIS_BIT);  // Disable sequential write/read operation
    _eio_write(EIO_REG_IODIR, EIO_GPIO_DIRECTIONS);
    _eio_write(EIO_REG_IPOL, 0);        // All non-inverting
    _eio_write(EIO_REG_GPINTEN, 0);     // No interrupts from pins
    _eio_write(EIO_REG_DEFVAL, 0);      // 0 defaults for interrupts
    _eio_write(EIO_REG_INTCON, 0xFF);   // Interrupt compare to default
}

