/**
 * Expansion I/O SPI operations.
 *
 * The Expansion I/O SPI is shared with the Display. In addition, the SPI Chip-Selects
 * are generated by a single 2:4 decoder, such that only a single SPI device can be
 * selected at a time.
 *
 * The reason the devices are split across two HW SPI units is because the Touch
 * Panel SCK speed is much slower than the Display and the Expansion I/O.
 *
 * Copyright 2023-25 AESilky
 * SPDX-License-Identifier: MIT License
 *
 */
#include "expio.h"
#include "board.h"
#include "system_defs.h"
#include "spi_ops.h"

#define EIO_CONTROL_BYTE    0x40    // 0100 0 (fixed) 00 (addr) x (0=WR, 1=RD)
#define EIO_CONTROL_WR_EN   0x00    // Bit-0 is WR/RD Control 0=WR
#define EIO_CONTROL_RD_EN   0x01    //                        1=RD

// Note: The final part of the definition names below are not the most clear,
// but they match the Microchip MCP23S08 Datasheet. This makes it easier to
// correlate information between the datasheet and this module.

#define EIO_REG_IODIR       0x00  // I/O Direction. 1=Input, 0=Output (R/W, POR=1111 1111)
#define EIO_REG_IPOL        0x01  // Input Polarity. 1=Invert (R/W, POR=0000 0000)
#define EIO_REG_GPINTEN     0x02  // Interrupt-On-Change enable. 1=Enable (R/W, POR=0000 0000)
#define EIO_REG_DEFVAL      0x03  // Default Value for IntOnChg. (R/W, POR=0000 0000)
#define EIO_REG_INTCON      0x04  // Interrupt Control. Compare to Default or Previous. (R/W, POR=0000 0000)
#define EIO_REG_IOCON       0x05  // Device Configuration. See bits below. (R/W, POR=xx00 000x)
#define EIO_IOCON_SEQOP_DIS_BIT     0x20  // Sequential Operation. Bit Set/Clr in IOCON Register
#define EIO_IOCON_DISSLW_BIT        0x10  // SDA Slew Rate. Bit Set/Clr in IOCON Register
#define EIO_IOCON_HAEN_BIT          0x08  // HW ADDR Enable. Bit Set/Clr in IOCON Register
#define EIO_IOCON_ODR_BIT           0x04  // Open-Drain Int Pin Enable. Bit Set/Clr in IOCON Register
#define EIO_IOCON_INTPOL_BIT        0x02  // Int Polarity. Bit Set/Clr in IOCON Register
#define EIO_REG_GPPU        0x06  // Pull-Up control. 1=PU (R/W, POR=)
#define EIO_REG_INTF        0x07  // Interrupt Flag. 1=Pin caused int. (RO, POR=0000 0000)
#define EIO_REG_INTCAP      0x08  // Interrupt Capture. Port values when int first occurs.
#define EIO_REG_GPIO        0x09  // GPIO (port) value. Reads current pin values, Write sets OLAT.
#define EIO_REG_OLAT        0x0A  // Output Latch. Writing sets pins configured as Output. Read is of last written value.

// Expansion I/O Board Pins

#define EIO_AGPI_0                      0       // AGPI_0 (IN)
#define EIO_AGPI_0_MASK                 0x01    // Mask for correct bit
#define EIO_AGPI_0_SHIFT                0       // Shift to move bit to/from 0
#define EIO_AGPI_1                      1       // AGPI_1 (IN)
#define EIO_AGPI_1_MASK                 0x02    // Mask for correct bit
#define EIO_AGPI_1_SHIFT                1       // Shift to move bit to/from 0
#define EIO_AGPO_2                      2       // AGPO_2 (OUT)
#define EIO_AGPO_2_MASK                 0x04    // Mask for correct bit
#define EIO_AGPO_2_SHIFT                2       // Shift to move bit to/from 0
#define EIO_AGPO_3                      3       // AGPO_3 (OUT)
#define EIO_AGPO_3_MASK                 0x08    // Mask for correct bit
#define EIO_AGPO_3_SHIFT                3       // Shift to move bit to/from 0
#define EIO_LED_A                       4       // Aux General Purpose 4 - Connected to a header and LED-A (OUT)
#define EIO_LED_A_MASK                  0x10    // Mask for correct bit
#define EIO_LED_A_SHIFT                 4       // Shift to move bit to/from 0
#define EIO_LED_B                       5       // Aux General Purpose 5 - Connected to a header and LED-B (OUT)
#define EIO_LED_B_MASK                  0x20    // Mask for correct bit
#define EIO_LED_B_SHIFT                 5       // Shift to move bit to/from 0
#define EIO_DISPLAY_BL_EN               6       // Display Backlight Enable (OUT)
#define EIO_DISPLAY_BL_EN_MASK          0x40    // Mask for correct bit
#define EIO_DISPLAY_BL_EN_SHIFT         6       // Shift to move bit to/from 0
#define EIO_BOARD_ADDR                  7       // Board Address (IN)
#define EIO_BOARD_ADDR_MASK             0x80    // Mask for correct bit
#define EIO_BOARD_ADDR_SHIFT            7       // Shift to move bit to/from 0
//
#define EIO_GPIO_DIRECTIONS             0x80  // 1000 0011

/** Flag to know if the module has been initialized */
static bool _initialized = false;

/** @brief Last written Output Latch value (OLAT). Needed to OR-in new values. */
static uint8_t _olat;

/**
 * Set the chip select for the Expansion I/O.
 *
 */
static void _cs(bool sel) {
    if (sel) {
        spi_expio_select();
    }
    else {
        spi_none_select();
    }
}

static void _op_begin() {
    if (!_initialized) {
        board_panic("expio_module_init not called.");
    }
    spi_expio_begin();
    _cs(true);
}

static void _op_end() {
    _cs(false);
    spi_expio_end();
}


/*
 * Runs _op_begin/_op_end
 */
static uint8_t _eio_read(uint8_t reg) {
    uint8_t v;
    uint8_t buf[] = { EIO_CONTROL_BYTE | EIO_CONTROL_RD_EN, reg };
    _op_begin();
    {
        spi_expio_write8_buf(buf, 2);
        v = spi_expio_read8(0xff);
    }
    _op_end();
    return v;
}

/*
 * Runs _op_begin/_op_end
 */
static void _eio_write(uint8_t reg, uint8_t val) {
    uint8_t buf[] = { EIO_CONTROL_BYTE | EIO_CONTROL_WR_EN, reg, val };
    _op_begin();
    {
        spi_expio_write8_buf(buf, 3);
    }
    _op_end();
}

uint8_t eio_board_addr(void) {
    uint8_t r = 0;
    r = _eio_read(EIO_REG_GPIO);
    r = ((r & EIO_BOARD_ADDR_MASK) > EIO_BOARD_ADDR_SHIFT);
    return r;
}

void eio_display_backlight_on(bool on) {
    // Gen OLAT value
    uint8_t b = EIO_DISPLAY_BL_EN_MASK;
    _olat = (on ? (_olat | b) : (_olat & ~b));
    _eio_write(EIO_REG_OLAT, _olat);
}

void eio_leda_on(bool on) {
    // Gen OLAT value
    uint8_t b = EIO_LED_A_MASK;
    _olat = (on ? (_olat | b) : (_olat & ~b));
    _eio_write(EIO_REG_OLAT, _olat);
}

void eio_ledb_on(bool on) {
    // Gen OLAT value
    uint8_t b = EIO_LED_B_MASK;
    _olat = (on ? (_olat | b) : (_olat & ~b));
    _eio_write(EIO_REG_OLAT, _olat);
}

void expio_module_init(void) {
    if (_initialized) {
        board_panic("expio_module_init called multiple times.");
    }
    _initialized = true;

    // Values are written to all of the chip's registers, even though many
    // contain the desired values after the chip's Power-On-Reset.
    _eio_write(EIO_REG_IOCON, EIO_IOCON_SEQOP_DIS_BIT); // Disable sequential write/read operation
    _eio_write(EIO_REG_IODIR, EIO_GPIO_DIRECTIONS);     // Set the Input/Output pin directions
    _eio_write(EIO_REG_IPOL, 0);        // All non-inverting
    _eio_write(EIO_REG_GPINTEN, 0);     // No interrupts from pins
    _eio_write(EIO_REG_DEFVAL, 0);      // 0 defaults for interrupts
    _eio_write(EIO_REG_INTCON, 0xFF);   // Interrupt compare to default
    _eio_write(EIO_REG_OLAT, 0);        // Output Latch - All 0's
    _olat = 0;
}

