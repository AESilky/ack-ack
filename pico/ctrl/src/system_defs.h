/*!
 * \brief Definitions for the board hardware.
 * \ingroup board
 *
 * This contains most of the definitions for the board. There are some additional
 * definitions in the display, expio, and curswitch modules.
 *
 * Copyright 2023-24 AESilky
 *
 * SPDX-License-Identifier: MIT
 */
#ifndef _SYSTEM_DEFS_H_
#define _SYSTEM_DEFS_H_
#ifdef __cplusplus
extern "C" {
#endif

#define VERSION_INFO "HWControl v0.1"  // ZZZ get from a central name/version string


#include "pico/stdlib.h"
#undef putc     // Undefine so the standard macros will not be used
#undef putchar  // Undefine so the standard macros will not be used

#include "hardware/adc.h"
#include "hardware/exception.h"
#include "hardware/gpio.h"
#include "hardware/i2c.h"
#include "hardware/pio.h"
#include "hardware/spi.h"
#include "hardware/uart.h"
#include "pico/multicore.h"

#include "hardware/pio.h"
#define ADC_INPUT_0             0               // ADC-0 on GPIO-26 (used with 'adc_select_input')
#define ADC_INPUT_1             1               // ADC-1 on GPIO-27 (used with 'adc_select_input')
#define ADC_INPUT_2             2               // ADC-2 on GPIO-28 (used with 'adc_select_input')
#define ADC_CHIP_TEMP           3               // Internal temperature sensor  (used with 'adc_select_input')

// SPI
//
// Note: Values (Pins) are the GPIO number, not the physical pins on the device.
//

// SPI 0 is used for the Display. Display SCL-RD 6.6MHz (150ns) and the
// Expansion I/O. Expansion I/O SCL 10.0MHz (100ns).
// 5MHz will be used to be compatible with both and provide margin.
//
#define SPI_DISP_EXP_DEVICE     spi0            // Hardware SPI to use
#define SPI_DISP_EXP_MISO       16              // DP-21
#define SPI_DISP_EXP_MOSI       19              // DP-25
#define SPI_DISP_EXP_SCK        18              // DP-24
#define SPI_DISP_CD             17              // DP-22
#define SPI_DISP_EXP_SPEED      (5500 * 1000)   // 5.5MHz

// SPI 1 is used for the Touch Panel. Touch Panel SCL-RD 2.5MHz(400ns)
// 2MHz will be used to provide margin.
//
#define SPI_TOUCH_DEVICE        spi1            // Hardware SPI to use
#define SPI_TOUCH_MISO          12              // DP-16
#define SPI_TOUCH_MOSI          11              // DP-15
#define SPI_TOUCH_SCK           10              // DP-14
#define SPI_TOUCH_SPEED         (2000 * 1000)   // 2MHz

// Chip selects for the SPI devices are generated by 2:4 decoder
// The decoder is driven by GPIO-8 for A0 and GPIO-13 for A1
//
#define SPI_ADDR_0               8              // DP-11
#define SPI_ADDR_1              13              // DP-17
#define SPI_ADDR_MASK           0x00002100      // Mask to set both bits at once: 0000 0000 0000 0000 0010 0001 0000 0000
#define SPI_DISP_CS_ADDR         0              // Display CS is Addr-0
#define SPI_TOUCH_CS_ADDR        1              // Touch Panel CS is Addr-1
#define SPI_EXPANSION_CS_ADDR    2              // Expansion IO is Addr-2
#define SPI_NONE_CS_ADDR         3              // Addr to use to select no SPI device

// UART Functions
//
#define HOST_COMM_UART          uart0           // UART-0 is used to communicate with the host
#define HOST_COMM_TX             0              // DP-1
#define HOST_COMM_RX             1              // DP-2
#define SERVO_CTRL_UART         uart1           // UART-1 is used to control the bus-servos
#define SERVO_CTRL_TX            4              // DP-6
#define SERVO_CTRL_RX            5              // DP-7
#define SERVO_CTRL_IRQ          UART1_IRQ       // UART-1 IRQ for received data
#define SERVO_CTRL_TX_EN_GPIO    2              // DP-4 The Bus Servo uses a single wire. This enables TX
#define SERVO_CTRL_TX_EN         0              // TX enable is active low
#define SERVO_CTRL_TX_DIS        1              // TX disable is active high

// Multiplexed Sensor Functionality
//
// Three GPIO (outputs) enable 1 of 8 devices. The result is read on another GPIO (input).
// For most, the sensor is digital and will be LOW (0) when it is active. However, it
// is possible that the device provides an analog signal. Therefore, the read is on
// GPIO-26, which is ADC-0. To allow PIO control, the select GPIOs and the input GPIO
// are sequential.
//
#define SENSOR_SEL_A0           20              // DP-26
#define SENSOR_SEL_A1           21              // DP-27
#define SENSOR_SEL_A2           22              // DP-29
#define SENSOR_READ             26              // DP-31
#define SENSOR_READ_ADC         adc0            // ADC-0 is used for analog sensors

// PIO Blocks
//
#define PIO_ROTARY_BLOCK        pio0            // PIO Block 0 is used to decode the quadrature signal
#define PIO_ROTARY_SM            0              // State Machine 0 is used for the rotary quad decode
#define PIO_ROTARY_IRQ          PIO0_IRQ_0      // PIO IRQ to use for Sensor reading change
#define PIO_SENSE_BLOCK         pio1            // PIO Block 1 is used to select and read the Multiplexed Sensors
#define PIO_IR_A_SM             0               // State Machine 0 is used to read the front IR (A)
#define PIO_IR_B_SM             1               // State Machine 1 is used to read the rear IR (B)

// I2C is brought out to connectors to allow external devices like Spektrum XBUS, ADC Devices, NeoPixel, etc.
#define I2C_EXTERN              i2c0
#define I2C_EXTERN_SDA           6              // DP-9  Serial Data
#define I2C_EXTERN_SCL           7              // DP-10 Serial Clock
#define I2C_EXTERN_CLK_SPEED     (400 * 1000)   // 400kHz

// RC Receiver and Telemetry input from FrSKY SBUS or Spektrum  DSMX
// These are serial input that could be decoded using a PIO
#define RC_RXTEL_GPIO            9              // DP-12

// Rotary Encoder Input
// This is a A/B quadrature encoder that can be decoded using a PIO (must be sequential)
#define ROTARY_A_GPIO           14              // DP-19
#define ROTARY_B_GPIO           15              // DP-20

// Other GPIO
//
#define SERVO_PWR_CURSENSE_GPIO 27              // Servo Power Current Sense from High-Side Switch
#define SERVO_PWR_CURSENSE_ADC  ADC_INPUT_1     // Current Sense is on ADC-1
#define SW_BANK_GPIO            28              // Switch Matrix Bank
#define SW_MAIN_USER_GPIO       SW_BANK_GPIO    // Main User Switch is GND on the Switch Matrix Bank
#define SW_BANK_ADC             ADC_INPUT_2     // Switch bank is read using ADC-2
#define SW_MAIN_USER_PRESSED     0              // Input (digital) is low when the main switch is pressed
#define SW_MAIN_USER_RELEASED    1              // Input (digital) is high when the main switch is not pressed

// PWM - Used for a recurring interrupt for scheduled messages, sleep, housekeeping
//
#define CMT_PWM_RECINT_SLICE     7              // RP2040 has 8 slices. Use the last one for this.

// IRQ Inputs
//
#define IRQ_INPUT_SW            SW_BANK_GPIO    // DP-34
// The IRQ from the Touch Panel and the Expansion I/O, along with the Wakeup signal
// (from the USB-2 RTS) are OR'ed together and detected on GPIO-3 (DP-5)
#define IRQ_WU_TOUCH_EXP         3              // DP-5
#define IRQ_ROTARY_TURN         14              // DP-19

// The Switch Matrix is read using the ADC. See the `curswitch` module for details.
//
#define SWITCH_LONGPRESS_MS 800     // 0.8 seconds (800ms) is considered a 'long press'
#define SWITCH_REPEAT_MS 250        // If a switch is long-pressed, repeat it every 1/4 second.

#ifdef __cplusplus
}
#endif
#endif // _SYSTEM_DEFS_H_
